"""
Vulnerability Scanner with Nuclei Integration
Automated vulnerability detection and CVE mapping
"""
import asyncio
import subprocess
import json
import yaml
from typing import List, Dict, Optional
import asyncpg
from dataclasses import dataclass
import aiohttp
import logging

logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    cve_id: Optional[str]
    severity: str
    title: str
    description: str
    cvss_score: float
    asset_id: str
    metadata: Dict
    exploitable: bool = False

class VulnerabilityScanner:
    def __init__(self, db_pool: asyncpg.Pool):
        self.db_pool = db_pool
        self.nuclei_templates = "/opt/nuclei-templates"
        self.cve_database = {}
    
    async def scan_with_nuclei(self, target: str) -> List[Vulnerability]:
        """Run Nuclei vulnerability scan"""
        vulnerabilities = []
        
        try:
            # Run Nuclei scan
            cmd = [
                "nuclei",
                "-target", target,
                "-json",
                "-severity", "low,medium,high,critical",
                "-rate-limit", "10",
                "-timeout", "30"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                # Parse Nuclei JSON output
                for line in stdout.decode().strip().split('\n'):
                    if line:
                        try:
                            result = json.loads(line)
                            vuln = await self._parse_nuclei_result(result, target)
                            if vuln:
                                vulnerabilities.append(vuln)
                        except json.JSONDecodeError:
                            continue
            else:
                logger.error(f"Nuclei scan failed: {stderr.decode()}")
        
        except Exception as e:
            logger.error(f"Nuclei scan error: {e}")
        
        return vulnerabilities
    
    async def _parse_nuclei_result(self, result: Dict, target: str) -> Optional[Vulnerability]:
        """Parse Nuclei scan result"""
        try:
            info = result.get('info', {})
            
            # Get asset ID from database
            asset_id = await self._get_asset_id(target)
            if not asset_id:
                return None
            
            vulnerability = Vulnerability(
                cve_id=self._extract_cve(info.get('reference', [])),
                severity=info.get('severity', 'unknown').lower(),
                title=info.get('name', 'Unknown Vulnerability'),
                description=info.get('description', ''),
                cvss_score=self._calculate_cvss(info.get('severity', 'unknown')),
                asset_id=asset_id,
                metadata={
                    'template_id': result.get('template-id', ''),
                    'matcher_name': result.get('matcher-name', ''),
                    'matched_at': result.get('matched-at', ''),
                    'tags': info.get('tags', []),
                    'reference': info.get('reference', [])
                },
                exploitable=self._is_exploitable(info.get('tags', []))
            )
            
            return vulnerability
            
        except Exception as e:
            logger.error(f"Failed to parse Nuclei result: {e}")
            return None
    
    def _extract_cve(self, references: List[str]) -> Optional[str]:
        """Extract CVE ID from references"""
        for ref in references:
            if 'CVE-' in ref:
                # Extract CVE-YYYY-NNNN pattern
                import re
                match = re.search(r'CVE-\d{4}-\d{4,7}', ref)
                if match:
                    return match.group(0)
        return None
    
    def _calculate_cvss(self, severity: str) -> float:
        """Convert severity to CVSS score"""
        severity_map = {
            'critical': 9.5,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5,
            'info': 0.0
        }
        return severity_map.get(severity.lower(), 0.0)
    
    def _is_exploitable(self, tags: List[str]) -> bool:
        """Determine if vulnerability is exploitable"""
        exploitable_tags = ['rce', 'sqli', 'xss', 'lfi', 'rfi', 'xxe', 'ssti']
        return any(tag.lower() in exploitable_tags for tag in tags)
    
    async def _get_asset_id(self, target: str) -> Optional[str]:
        """Get asset ID from database"""
        try:
            async with self.db_pool.acquire() as conn:
                row = await conn.fetchrow("""
                    SELECT id FROM asm.assets 
                    WHERE value = $1 OR value LIKE $2
                    LIMIT 1
                """, target, f"%{target}%")
                
                return str(row['id']) if row else None
        except Exception as e:
            logger.error(f"Failed to get asset ID: {e}")
            return None
    
    async def custom_web_scan(self, target: str) -> List[Vulnerability]:
        """Custom web application vulnerability scan"""
        vulnerabilities = []
        
        # SQL Injection tests
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT NULL, NULL, NULL --"
        ]
        
        for payload in sql_payloads:
            vuln = await self._test_sql_injection(target, payload)
            if vuln:
                vulnerabilities.append(vuln)
        
        # XSS tests
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>"
        ]
        
        for payload in xss_payloads:
            vuln = await self._test_xss(target, payload)
            if vuln:
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_sql_injection(self, target: str, payload: str) -> Optional[Vulnerability]:
        """Test for SQL injection vulnerability"""
        try:
            async with aiohttp.ClientSession() as session:
                # Test GET parameter
                url = f"{target}?id={payload}"
                async with session.get(url) as response:
                    text = await response.text()
                    
                    # Look for SQL error indicators
                    sql_errors = [
                        "mysql_fetch_array",
                        "ORA-01756",
                        "Microsoft OLE DB Provider",
                        "PostgreSQL query failed",
                        "SQLite/JDBCDriver"
                    ]
                    
                    if any(error in text for error in sql_errors):
                        asset_id = await self._get_asset_id(target)
                        if asset_id:
                            return Vulnerability(
                                cve_id=None,
                                severity="high",
                                title="SQL Injection Vulnerability",
                                description=f"SQL injection detected with payload: {payload}",
                                cvss_score=8.5,
                                asset_id=asset_id,
                                metadata={
                                    "payload": payload,
                                    "method": "GET",
                                    "parameter": "id",
                                    "evidence": text[:200]
                                },
                                exploitable=True
                            )
        except Exception as e:
            logger.debug(f"SQL injection test failed: {e}")
        
        return None
    
    async def _test_xss(self, target: str, payload: str) -> Optional[Vulnerability]:
        """Test for XSS vulnerability"""
        try:
            async with aiohttp.ClientSession() as session:
                # Test reflected XSS
                url = f"{target}?q={payload}"
                async with session.get(url) as response:
                    text = await response.text()
                    
                    if payload in text and "<script>" in payload:
                        asset_id = await self._get_asset_id(target)
                        if asset_id:
                            return Vulnerability(
                                cve_id=None,
                                severity="medium",
                                title="Cross-Site Scripting (XSS)",
                                description=f"Reflected XSS detected with payload: {payload}",
                                cvss_score=6.1,
                                asset_id=asset_id,
                                metadata={
                                    "payload": payload,
                                    "type": "reflected",
                                    "parameter": "q"
                                },
                                exploitable=True
                            )
        except Exception as e:
            logger.debug(f"XSS test failed: {e}")
        
        return None
    
    async def enrich_with_cve_data(self, vulnerability: Vulnerability) -> Vulnerability:
        """Enrich vulnerability with CVE database information"""
        if not vulnerability.cve_id:
            return vulnerability
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"https://cve.circl.lu/api/cve/{vulnerability.cve_id}"
                async with session.get(url) as response:
                    if response.status == 200:
                        cve_data = await response.json()
                        
                        # Update vulnerability with CVE data
                        if 'cvss' in cve_data:
                            vulnerability.cvss_score = float(cve_data['cvss'])
                        
                        if 'summary' in cve_data:
                            vulnerability.description = cve_data['summary']
                        
                        vulnerability.metadata.update({
                            'cve_published': cve_data.get('Published', ''),
                            'cve_modified': cve_data.get('Modified', ''),
                            'cve_references': cve_data.get('references', [])
                        })
        
        except Exception as e:
            logger.error(f"Failed to enrich CVE data: {e}")
        
        return vulnerability
    
    async def store_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> bool:
        """Store vulnerabilities in database"""
        try:
            async with self.db_pool.acquire() as conn:
                for vuln in vulnerabilities:
                    await conn.execute("""
                        INSERT INTO asm.vulnerabilities 
                        (asset_id, cve_id, severity, title, description, cvss_score, 
                         exploitable, metadata)
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                        ON CONFLICT (asset_id, cve_id, title) DO UPDATE SET
                        cvss_score = $6, metadata = $8, created_at = NOW()
                    """, vuln.asset_id, vuln.cve_id, vuln.severity, vuln.title,
                    vuln.description, vuln.cvss_score, vuln.exploitable,
                    json.dumps(vuln.metadata))
            
            logger.info(f"Stored {len(vulnerabilities)} vulnerabilities")
            return True
        except Exception as e:
            logger.error(f"Failed to store vulnerabilities: {e}")
            return False
    
    async def full_vulnerability_scan(self, target: str) -> Dict[str, List[Vulnerability]]:
        """Complete vulnerability assessment"""
        results = {
            "nuclei": [],
            "custom": [],
            "enriched": []
        }
        
        # Nuclei scan
        results["nuclei"] = await self.scan_with_nuclei(target)
        
        # Custom web scan
        results["custom"] = await self.custom_web_scan(target)
        
        # Enrich with CVE data
        all_vulns = results["nuclei"] + results["custom"]
        for vuln in all_vulns:
            enriched = await self.enrich_with_cve_data(vuln)
            results["enriched"].append(enriched)
        
        # Store results
        await self.store_vulnerabilities(results["enriched"])
        
        return results

# Usage example
async def run_vulnerability_scan():
    db_pool = await asyncpg.create_pool("postgresql://user:pass@localhost/infinite_labyrinth")
    scanner = VulnerabilityScanner(db_pool)
    
    results = await scanner.full_vulnerability_scan("https://example.com")
    
    print(f"Nuclei vulnerabilities: {len(results['nuclei'])}")
    print(f"Custom scan results: {len(results['custom'])}")
    print(f"Total enriched: {len(results['enriched'])}")
    
    return results