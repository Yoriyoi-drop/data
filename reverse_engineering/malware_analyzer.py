"""
Advanced Malware Analysis and Reverse Engineering
"""
import os
import hashlib
import json
import re
from typing import Dict, List, Any
from dataclasses import dataclass
from .core_engine import reverse_engine

@dataclass
class MalwareSignature:
    name: str
    pattern: bytes
    description: str
    severity: str

class MalwareAnalyzer:
    def __init__(self):
        self.signatures = self._load_signatures()
        self.behavioral_patterns = self._load_behavioral_patterns()
    
    def analyze_malware(self, file_path: str) -> Dict[str, Any]:
        """Comprehensive malware analysis"""
        analysis = {
            'file_info': self._get_file_info(file_path),
            'static_analysis': self._static_analysis(file_path),
            'signature_matches': self._signature_scan(file_path),
            'behavioral_analysis': self._behavioral_analysis(file_path),
            'network_indicators': self._extract_network_iocs(file_path),
            'crypto_analysis': self._analyze_crypto(file_path),
            'packer_detection': self._detect_packer(file_path),
            'threat_score': 0
        }
        
        # Calculate threat score
        analysis['threat_score'] = self._calculate_threat_score(analysis)
        
        return analysis
    
    def extract_iocs(self, file_path: str) -> Dict[str, List[str]]:
        """Extract Indicators of Compromise"""
        iocs = {
            'file_hashes': [],
            'domains': [],
            'ips': [],
            'urls': [],
            'registry_keys': [],
            'file_paths': [],
            'mutexes': []
        }
        
        try:
            # File hash
            iocs['file_hashes'].append(self._get_file_hash(file_path))
            
            # Extract from strings
            strings = reverse_engine._extract_strings(file_path)
            for string in strings:
                # Domain patterns
                if re.match(r'^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', string):
                    iocs['domains'].append(string)
                
                # IP patterns
                if re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', string):
                    iocs['ips'].append(string)
                
                # URL patterns
                if string.startswith(('http://', 'https://', 'ftp://')):
                    iocs['urls'].append(string)
                
                # Registry key patterns
                if string.startswith(('HKEY_', 'SOFTWARE\\', 'SYSTEM\\')):
                    iocs['registry_keys'].append(string)
                
                # File path patterns
                if '\\' in string and len(string) > 10:
                    iocs['file_paths'].append(string)
        
        except Exception:
            pass
        
        return iocs
    
    def generate_yara_rule(self, file_path: str, rule_name: str) -> str:
        """Generate YARA rule for the analyzed file"""
        analysis = reverse_engine.analyze_binary(file_path)
        file_hash = self._get_file_hash(file_path)
        
        yara_rule = f"""
rule {rule_name}
{{
    meta:
        description = "Auto-generated rule for {os.path.basename(file_path)}"
        author = "Infinite AI Security"
        date = "2024-01-01"
        hash = "{file_hash}"
    
    strings:
"""
        
        # Add string patterns
        for i, string in enumerate(analysis.strings[:10]):
            if len(string) > 6:
                yara_rule += f'        $s{i} = "{string}"\n'
        
        # Add hex patterns
        yara_rule += """
    condition:
        any of ($s*)
}"""
        
        return yara_rule
    
    def _get_file_info(self, file_path: str) -> Dict:
        """Get basic file information"""
        try:
            stat = os.stat(file_path)
            return {
                'filename': os.path.basename(file_path),
                'size': stat.st_size,
                'md5': self._get_file_hash(file_path, 'md5'),
                'sha1': self._get_file_hash(file_path, 'sha1'),
                'sha256': self._get_file_hash(file_path, 'sha256')
            }
        except Exception:
            return {}
    
    def _static_analysis(self, file_path: str) -> Dict:
        """Perform static analysis"""
        analysis = reverse_engine.analyze_binary(file_path)
        
        return {
            'file_type': analysis.file_type,
            'architecture': analysis.architecture,
            'entry_point': analysis.entry_point,
            'sections': len(analysis.sections),
            'imports': len(analysis.imports),
            'exports': len(analysis.exports),
            'strings': len(analysis.strings),
            'functions': len(analysis.functions)
        }
    
    def _signature_scan(self, file_path: str) -> List[Dict]:
        """Scan for malware signatures"""
        matches = []
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            for signature in self.signatures:
                if signature.pattern in data:
                    matches.append({
                        'name': signature.name,
                        'description': signature.description,
                        'severity': signature.severity
                    })
        
        except Exception:
            pass
        
        return matches
    
    def _behavioral_analysis(self, file_path: str) -> Dict:
        """Analyze behavioral patterns"""
        behavior = {
            'file_operations': [],
            'registry_operations': [],
            'network_operations': [],
            'process_operations': [],
            'persistence_mechanisms': []
        }
        
        try:
            imports = reverse_engine._extract_imports(file_path)
            
            # Analyze imports for behavioral indicators
            for imp in imports:
                if 'CreateFile' in imp or 'WriteFile' in imp:
                    behavior['file_operations'].append(imp)
                elif 'RegSet' in imp or 'RegCreate' in imp:
                    behavior['registry_operations'].append(imp)
                elif 'socket' in imp or 'connect' in imp:
                    behavior['network_operations'].append(imp)
                elif 'CreateProcess' in imp or 'OpenProcess' in imp:
                    behavior['process_operations'].append(imp)
        
        except Exception:
            pass
        
        return behavior
    
    def _extract_network_iocs(self, file_path: str) -> Dict:
        """Extract network indicators"""
        return reverse_engine.analyze_network_behavior(file_path)
    
    def _analyze_crypto(self, file_path: str) -> Dict:
        """Analyze cryptographic elements"""
        crypto_keys = reverse_engine.extract_crypto_keys(file_path)
        
        return {
            'keys_found': len(crypto_keys),
            'key_types': [key['type'] for key in crypto_keys],
            'encryption_apis': self._find_crypto_apis(file_path)
        }
    
    def _find_crypto_apis(self, file_path: str) -> List[str]:
        """Find cryptographic API calls"""
        crypto_apis = []
        try:
            imports = reverse_engine._extract_imports(file_path)
            crypto_functions = ['CryptEncrypt', 'CryptDecrypt', 'CryptGenKey', 'AES', 'RSA']
            
            for imp in imports:
                for crypto_func in crypto_functions:
                    if crypto_func in imp:
                        crypto_apis.append(imp)
        except Exception:
            pass
        
        return crypto_apis
    
    def _detect_packer(self, file_path: str) -> Dict:
        """Detect if binary is packed"""
        packer_info = {
            'is_packed': False,
            'packer_type': 'None',
            'confidence': 0.0
        }
        
        try:
            analysis = reverse_engine.analyze_binary(file_path)
            
            # Check for packer indicators
            if len(analysis.imports) < 10:
                packer_info['is_packed'] = True
                packer_info['confidence'] += 0.3
            
            # Check section names for packer signatures
            packer_sections = ['UPX0', 'UPX1', '.aspack', '.adata']
            for section in analysis.sections:
                if any(pack_sec in section.get('name', '') for pack_sec in packer_sections):
                    packer_info['is_packed'] = True
                    packer_info['packer_type'] = 'UPX/ASPack'
                    packer_info['confidence'] += 0.5
        
        except Exception:
            pass
        
        return packer_info
    
    def _calculate_threat_score(self, analysis: Dict) -> int:
        """Calculate overall threat score (0-100)"""
        score = 0
        
        # Signature matches
        score += len(analysis['signature_matches']) * 20
        
        # Behavioral indicators
        behavior = analysis['behavioral_analysis']
        score += len(behavior['file_operations']) * 2
        score += len(behavior['registry_operations']) * 3
        score += len(behavior['network_operations']) * 5
        score += len(behavior['process_operations']) * 4
        
        # Packer detection
        if analysis['packer_detection']['is_packed']:
            score += 15
        
        # Network IOCs
        network = analysis['network_indicators']
        score += len(network['domains']) * 3
        score += len(network['ips']) * 2
        
        return min(score, 100)
    
    def _get_file_hash(self, file_path: str, algorithm: str = 'sha256') -> str:
        """Calculate file hash"""
        try:
            hash_obj = getattr(hashlib, algorithm)()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_obj.update(chunk)
            return hash_obj.hexdigest()
        except Exception:
            return ""
    
    def _load_signatures(self) -> List[MalwareSignature]:
        """Load malware signatures"""
        return [
            MalwareSignature("Trojan.Generic", b"\x4d\x5a\x90\x00", "Generic trojan pattern", "High"),
            MalwareSignature("Backdoor.NetCat", b"nc.exe", "NetCat backdoor", "High"),
            MalwareSignature("Keylogger.Generic", b"GetAsyncKeyState", "Keylogger API", "Medium"),
            MalwareSignature("Ransomware.Encrypt", b"CryptEncrypt", "Encryption API", "High")
        ]
    
    def _load_behavioral_patterns(self) -> Dict:
        """Load behavioral analysis patterns"""
        return {
            'persistence': ['RegSetValue', 'CreateService', 'SetWindowsHook'],
            'evasion': ['IsDebuggerPresent', 'VirtualProtect', 'Sleep'],
            'data_theft': ['GetClipboardData', 'GetWindowText', 'ReadFile']
        }

# Global instance
malware_analyzer = MalwareAnalyzer()